
data True;
data False;

data 0;
data Suc *;

data Nil;
data Cons _ *;

data Leaf;
data Node _ * *;

let 1 = .Suc .0 ;
let 2 = .Suc .1 ;

let and = fn p q -> case p | .False -> .False | .True -> q end ;

let add = fix add x y -> case[add] x | .0 -> y   | .Suc x' -> .Suc (add x' y) end ;
let mul = fix mul x y -> case[mul] x | .0 -> .1 | .Suc x' -> .add y (mul x' y) end ;

let minus = fix minus x y ->
    case y
    | .0 -> x
    | .Suc y' ->
        case x
        | .0 -> .0
        | .Suc x' -> minus x' y'
        end
    end ;

let lt = fix lt x y ->
    case[lt1] x
    | .0 ->
        case[lt11] y
        | .0 -> .False
        | .Suc y -> .True
        end
    | .Suc x ->
        case[lt12] y
        | .0 -> .False
        | .Suc y -> lt x y
        end
    end ;

let lteq = fix lteq x y ->
    case x
    | .0 -> .True
    | .Suc x ->
        case y
        | .0 -> .False
        | .Suc y -> lteq x y
        end
    end ;

let eq = fix eq x y ->
    case x
    | .0 ->
        case y
        | .0 -> .True
        | .Suc y' -> .False
        end
    | .Suc x' ->
        case y
        | .0 -> .False
        | .Suc y' -> eq x' y'
        end
    end ;

let app = fix app xs ys ->
    case[app] xs
    | .Nil -> ys
    | .Cons x xs' -> .Cons x (app xs' ys)
    end ;

let take = fix take n xs ->
    case n
    | .0 -> .Nil
    | .Suc n' ->
        case xs
        | .Nil -> .Nil
        | .Cons x xs' -> .Cons x (take n' xs')
        end
    end ;

let drop = fix drop n xs ->
    case n
    | .0 -> xs
    | .Suc n' ->
        case xs
        | .Nil -> .Nil
        | .Cons x xs' -> drop n' xs'
        end
    end ;

let count = fix count n xs ->
    case[count1] xs
    | .Nil -> .0
    | .Cons x xs' ->
        case[count2] .eq n x
        | .True -> .Suc (count n xs')
        | .False -> count n xs'
        end
    end ;

let filter = fix filter p xs ->
    case xs
    | .Nil -> .Nil
    | .Cons x xs' ->
        case p x
        | .True -> .Cons x (filter p xs')
        | .False -> filter p xs'
        end
    end ;

let length = fix length xs ->
    case xs
    | .Nil -> .0
    | .Cons x xs' -> .Suc (length xs')
    end ;

let snoc = fn y -> fix snoc xs ->
    case[snoc] xs
    | .Nil -> .Cons y .Nil
    | .Cons x xs' -> .Cons x (snoc xs')
    end ;

let rev = fix rev xs ->
    case[rev] xs
    | .Nil -> .Nil
    | .Cons x xs' -> .app (rev xs') (.Cons x .Nil)
    end ;

let revSnoc = fn y -> fix revSnoc xs ->
    case[revsnoc] xs
    | .Nil -> .Cons y .Nil
    | .Cons x xs' -> .app (revSnoc xs') (.Cons x .Nil)
    end ;

let ones = fix ones -> .Cons .1 ones ;

let isSorted = fix isSorted xs ->
    case[sorted1] xs
    | .Nil -> .True
    | .Cons x xs' ->
      case[sorted2] xs'
      | .Nil -> .True
      | .Cons y ys -> .and (.lteq x y) (isSorted xs')
      end
    end ;

let insert = fix ins n xs ->
    case[ins1] xs
    | .Nil -> .Cons n .Nil
    | .Cons x xs' ->
      case[ins2] .lteq n x
      | .True -> .Cons n xs
      | .False -> .Cons x (ins n xs')
      end
    end ;

let insertsort = fix isort xs ->
    case[isort1] xs
    | .Nil -> .Nil
    | .Cons x xs' -> .insert x (isort xs')
    end ;

let flatten = fix flatten t ->
    case t
    | .Leaf -> .Leaf
    | .Node x t1 t2 ->
      .app (flatten t1) (.Cons x (flatten t2))
    end ;
