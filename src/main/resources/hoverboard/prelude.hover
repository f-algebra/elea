
data True;
data False;

data 0;
data Suc *;

data Nil;
data Cons _ *;

data Leaf;
data Node _ * *;

let 1 = Suc 0 ;
let 2 = Suc 1 ;

let And = fn p q -> case p | False -> False | True -> q end ;

let Add = fix add x y -> case[add] x | 0 -> y | Suc x' -> Suc (add x' y) end ;
let Mul = fix mul x y -> case[mul] x | 0 -> 1 | Suc x' -> Add y (mul x' y) end ;

let Lt = fix lt x y ->
    case[lt1] x
    | 0 ->
        case[lt11] y
        | 0 -> False
        | Suc y -> True
        end
    | Suc x ->
        case[lt12] y
        | 0 -> False
        | Suc y -> lt x y
        end
    end ;

let LtEq = fix lteq x y ->
    case x
    | 0 -> True
    | Suc x ->
        case y
        | 0 -> False
        | Suc y -> lteq x y
        end
    end ;

let Append = fix app xs ys ->
    case[app] xs
    | Nil -> ys
    | Cons x xs' -> Cons x (app xs' ys)
    end ;

let Snoc = fn y -> fix snoc xs ->
    case[snoc] xs
    | Nil -> Cons y Nil
    | Cons x xs' -> Cons x (snoc xs')
    end ;

let Reverse = fix rev xs ->
    case[rev] xs
    | Nil -> Nil
    | Cons x xs' -> Append (rev xs') (Cons x Nil)
    end ;

let ReverseSnoc = fn y -> fix rev xs ->
    case xs
    | Nil -> Cons y Nil
    | Cons x xs' -> Append (rev xs') (Cons x Nil)
    end ;

let Ones = fix ones -> Cons 1 ones ;

let IsSorted = fix srtd xs ->
    case[sorted1] xs
    | Nil -> True
    | Cons x xs' ->
      case[sorted2] xs'
      | Nil -> True
      | Cons y ys -> And (LtEq x y) (srtd xs')
      end
    end ;

let Insert = fix ins n xs ->
    case[ins1] xs
    | Nil -> Cons n Nil
    | Cons x xs' ->
      case[ins2] LtEq n x
      | True -> Cons n xs
      | False -> Cons x (ins n xs')
      end
    end ;

let InsertSort = fix isort xs ->
    case[isort1] xs
    | Nil -> Nil
    | Cons x xs' -> Insert x (isort xs')
    end ;

let Flatten = fix flat t ->
    case t
    | Leaf -> Leaf
    | Node x t1 t2 ->
      Append (flat t1) (Cons x (flat t2))
    end ;
